#!/usr/bin/env python

from collections import namedtuple

EQUAL = 0
SUBSTI = 1
INSERT = 2
DELETE = 3
Edit = namedtuple('Edit', ['edit_tag', 'weight'])


def min_score(tuples):
    """Given a named tuple edit_tag: weight, return a tuple of the min tag and its weight."""
    return min(tuples, key=lambda x: x.weight)


def compute_distance(s1, s2, all_edits=True, sub_weight=1, ins_weight=1, del_weight=1):
    """
    Given two strings (or lists) compute the minimum edit distance. Either returns the
    full array of all possible edits or just the score.
    Parameters:
        s1 (string or list object) - The first object to compare
        s2 (string or list object) - The second object to compare
        all_edits (bool) - Whether or not to return just the score or all edits
    Returns:
        If all_edits is True:
            return dictionary of dictionaries of tuples. The outer dict maps row indices
            to the inner dict. This dict maps column indices to tuples. The first element
            of the tuple is an int representing the operation used and the second is the
            score at that node. This is designed to work with get_edits.
        If all_edits is False:
            return just the minimum edit distance.
    """
    l1, l2 = len(s1) + 1, len(s2) + 1
    scores = {0: {i: Edit(INSERT, i) for i in range(l2)}}
    # For every word in both texts
    for i in range(1, l1):
        scores[i] = {0: Edit(DELETE, i)}
        for j in range(1, l2):
            # You don't have to change anything, the error hasn't changed
            if s1[i - 1] == s2[j - 1]:
                scores[i][j] = Edit(EQUAL, scores[i - 1][j - 1].weight)
            # Something happened
            else:
                scores[i][j] = min_score([Edit(SUBSTI, scores[i - 1][j - 1].weight + sub_weight),
                                          Edit(INSERT, scores[i][j - 1].weight + ins_weight),
                                          Edit(DELETE, scores[i - 1][j].weight + del_weight),
                                          ])
    if all_edits:
        return scores
    else:
        return scores[l1 - 1][l2 - 1].weight


def get_edits(bp):
    """
    Given a dictionary of scores generated by compute_distance, return
    the edits used to transition from the first to the second string.
    Parameters:
        bp (dict{int:dict{int:tuple}}) - dictionary of backpointers
    Returns:
        Tuple containing opcodes and counts.
        - opcodes (list) - the operations used to convert each token
        - counts (dict) - maps the operation to the number of times it was used
        The codes operation codes used are:
            ' ' - Denotes no change from s1 to s2
            's' - Substitution/Replacement
            'i' - Insertion
            'd' - Deletion
    """
    # Initialize starting objects and values
    edit_dict = {i: k for i, k in enumerate([' ', 's', 'i', 'd'])}
    counts = {symbol: 0 for symbol in ('s', 'i', 'd', ' ', 'Total')}
    x = len(bp) - 1
    y = len(bp[0]) - 1
    opcodes = ''
    # While counting backwards, can't be infinite because something always decrements
    while x > 0 or y > 0:
        counts['Total'] += 1
        this_op = bp[x][y].edit_tag
        opcodes += edit_dict[this_op]
        # Current operation was null or substitution
        if this_op == EQUAL or this_op == SUBSTI:
            counts[edit_dict[this_op]] += 1
            x = x - 1
            y = y - 1
        # Current operation was insertion
        elif this_op == INSERT:
            counts['i'] += 1
            y = y - 1
        # Current operation was deletion
        elif this_op == DELETE:
            counts['d'] += 1
            x = x - 1
        else:
            raise Exception('Invalid dynamic programming action in BP table!')
    return opcodes[::-1], counts


def pretty_print(s1, s2, edits):
    symbol_map = {' ': ' ', 's': '↕', 'i': '↓', 'd': '↑'}
    s1, s2 = list(s1)[::-1], list(s2)[::-1]
    if len(edits) < 60:
        s1_out, s2_out, e_out = '', '', ''
        for e in edits:
            e_out += symbol_map[e]
            if e == 'i':
                s1_out += '⨯'
                s2_out += s2.pop()
            elif e == 'd':
                s2_out += '⨯'
                s1_out += s1.pop()
            else:
                s1_out += s1.pop()
                s2_out += s2.pop()
        print('Edits:')
        print('', repr(s1_out))
        print('', repr(e_out))
        print('', repr(s2_out))
    else:
        print('Too many edits to display')


def main(s1, s2, weights, print_transformation=True, ignore_case=False):
    if ignore_case:
        s1, s2 = s1.lower(), s2.lower()
    l1, l2 = len(s1), len(s2)
    scores = compute_distance(s1, s2, **weights)
    min_distance = scores[l1][l2].weight
    # Backtrack to find the path of edits
    edits, counts = get_edits(scores)
    # Print results
    print('Min Edit Distance:', min_distance)
    print('Edit Tally:', counts)
    if print_transformation:
        pretty_print(s1, s2, edits)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Fuzzy Match: An algorithm to determine the similarity of strings')
    parser.add_argument('s1', metavar='input_string', type=str, help='the string to search for')
    parser.add_argument('s2', metavar='search_string', type=str, help='the string (or strings) to search in')
    parser.add_argument('-p', '--pretty_print', action='store_true', help='print in/out strings with transformations')
    parser.add_argument('-c', '--ignore_case', action='store_true', help='disregard differences in capitalization')
    parser.add_argument('-s', '--sub_weight', type=float, default=1, help='weight for substitution operation')
    parser.add_argument('-d', '--del_weight', type=float, default=1, help='weight for deletion operation')
    parser.add_argument('-i', '--ins_weight', type=float, default=1, help='weight for insertion operation')
    parser.set_defaults(pretty_print=False)
    parser.set_defaults(case_sensitive=False)

    args = parser.parse_args()
    edit_weights = {
        'sub_weight': args.sub_weight,
        'ins_weight': args.ins_weight,
        'del_weight': args.del_weight,
    }
    main(args.s1, args.s2, edit_weights, args.pretty_print, args.ignore_case)
